// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: base/rpc/rpc_header.proto

#ifndef PROTOBUF_base_2frpc_2frpc_5fheader_2eproto__INCLUDED
#define PROTOBUF_base_2frpc_2frpc_5fheader_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2006000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2006001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include "google/protobuf/descriptor.pb.h"
#include "base/util/pb_util.pb.h"
// @@protoc_insertion_point(includes)

namespace base {
namespace rpc {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_base_2frpc_2frpc_5fheader_2eproto();
void protobuf_AssignDesc_base_2frpc_2frpc_5fheader_2eproto();
void protobuf_ShutdownFile_base_2frpc_2frpc_5fheader_2eproto();

class UserInformationPB;
class ConnectionContextPB;
class SaslMessagePB;
class SaslMessagePB_SaslAuth;
class RemoteMethodPB;
class RequestIdPB;
class RequestHeader;
class ResponseHeader;
class ErrorStatusPB;

enum SaslMessagePB_SaslState {
  SaslMessagePB_SaslState_UNKNOWN = 999,
  SaslMessagePB_SaslState_SUCCESS = 0,
  SaslMessagePB_SaslState_NEGOTIATE = 1,
  SaslMessagePB_SaslState_INITIATE = 2,
  SaslMessagePB_SaslState_CHALLENGE = 3,
  SaslMessagePB_SaslState_RESPONSE = 4
};
bool SaslMessagePB_SaslState_IsValid(int value);
const SaslMessagePB_SaslState SaslMessagePB_SaslState_SaslState_MIN = SaslMessagePB_SaslState_SUCCESS;
const SaslMessagePB_SaslState SaslMessagePB_SaslState_SaslState_MAX = SaslMessagePB_SaslState_UNKNOWN;
const int SaslMessagePB_SaslState_SaslState_ARRAYSIZE = SaslMessagePB_SaslState_SaslState_MAX + 1;

const ::google::protobuf::EnumDescriptor* SaslMessagePB_SaslState_descriptor();
inline const ::std::string& SaslMessagePB_SaslState_Name(SaslMessagePB_SaslState value) {
  return ::google::protobuf::internal::NameOfEnum(
    SaslMessagePB_SaslState_descriptor(), value);
}
inline bool SaslMessagePB_SaslState_Parse(
    const ::std::string& name, SaslMessagePB_SaslState* value) {
  return ::google::protobuf::internal::ParseNamedEnum<SaslMessagePB_SaslState>(
    SaslMessagePB_SaslState_descriptor(), name, value);
}
enum ErrorStatusPB_RpcErrorCodePB {
  ErrorStatusPB_RpcErrorCodePB_FATAL_UNKNOWN = 10,
  ErrorStatusPB_RpcErrorCodePB_ERROR_APPLICATION = 1,
  ErrorStatusPB_RpcErrorCodePB_ERROR_NO_SUCH_METHOD = 2,
  ErrorStatusPB_RpcErrorCodePB_ERROR_NO_SUCH_SERVICE = 3,
  ErrorStatusPB_RpcErrorCodePB_ERROR_SERVER_TOO_BUSY = 4,
  ErrorStatusPB_RpcErrorCodePB_ERROR_INVALID_REQUEST = 5,
  ErrorStatusPB_RpcErrorCodePB_ERROR_REQUEST_STALE = 6,
  ErrorStatusPB_RpcErrorCodePB_FATAL_SERVER_SHUTTING_DOWN = 11,
  ErrorStatusPB_RpcErrorCodePB_FATAL_INVALID_RPC_HEADER = 12,
  ErrorStatusPB_RpcErrorCodePB_FATAL_DESERIALIZING_REQUEST = 13,
  ErrorStatusPB_RpcErrorCodePB_FATAL_VERSION_MISMATCH = 14,
  ErrorStatusPB_RpcErrorCodePB_FATAL_UNAUTHORIZED = 15
};
bool ErrorStatusPB_RpcErrorCodePB_IsValid(int value);
const ErrorStatusPB_RpcErrorCodePB ErrorStatusPB_RpcErrorCodePB_RpcErrorCodePB_MIN = ErrorStatusPB_RpcErrorCodePB_ERROR_APPLICATION;
const ErrorStatusPB_RpcErrorCodePB ErrorStatusPB_RpcErrorCodePB_RpcErrorCodePB_MAX = ErrorStatusPB_RpcErrorCodePB_FATAL_UNAUTHORIZED;
const int ErrorStatusPB_RpcErrorCodePB_RpcErrorCodePB_ARRAYSIZE = ErrorStatusPB_RpcErrorCodePB_RpcErrorCodePB_MAX + 1;

const ::google::protobuf::EnumDescriptor* ErrorStatusPB_RpcErrorCodePB_descriptor();
inline const ::std::string& ErrorStatusPB_RpcErrorCodePB_Name(ErrorStatusPB_RpcErrorCodePB value) {
  return ::google::protobuf::internal::NameOfEnum(
    ErrorStatusPB_RpcErrorCodePB_descriptor(), value);
}
inline bool ErrorStatusPB_RpcErrorCodePB_Parse(
    const ::std::string& name, ErrorStatusPB_RpcErrorCodePB* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ErrorStatusPB_RpcErrorCodePB>(
    ErrorStatusPB_RpcErrorCodePB_descriptor(), name, value);
}
enum RpcFeatureFlag {
  UNKNOWN = 0,
  APPLICATION_FEATURE_FLAGS = 1
};
bool RpcFeatureFlag_IsValid(int value);
const RpcFeatureFlag RpcFeatureFlag_MIN = UNKNOWN;
const RpcFeatureFlag RpcFeatureFlag_MAX = APPLICATION_FEATURE_FLAGS;
const int RpcFeatureFlag_ARRAYSIZE = RpcFeatureFlag_MAX + 1;

const ::google::protobuf::EnumDescriptor* RpcFeatureFlag_descriptor();
inline const ::std::string& RpcFeatureFlag_Name(RpcFeatureFlag value) {
  return ::google::protobuf::internal::NameOfEnum(
    RpcFeatureFlag_descriptor(), value);
}
inline bool RpcFeatureFlag_Parse(
    const ::std::string& name, RpcFeatureFlag* value) {
  return ::google::protobuf::internal::ParseNamedEnum<RpcFeatureFlag>(
    RpcFeatureFlag_descriptor(), name, value);
}
// ===================================================================

class UserInformationPB : public ::google::protobuf::Message {
 public:
  UserInformationPB();
  virtual ~UserInformationPB();

  UserInformationPB(const UserInformationPB& from);

  inline UserInformationPB& operator=(const UserInformationPB& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const UserInformationPB& default_instance();

  void Swap(UserInformationPB* other);

  // implements Message ----------------------------------------------

  UserInformationPB* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const UserInformationPB& from);
  void MergeFrom(const UserInformationPB& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string effective_user = 1;
  inline bool has_effective_user() const;
  inline void clear_effective_user();
  static const int kEffectiveUserFieldNumber = 1;
  inline const ::std::string& effective_user() const;
  inline void set_effective_user(const ::std::string& value);
  inline void set_effective_user(const char* value);
  inline void set_effective_user(const char* value, size_t size);
  inline ::std::string* mutable_effective_user();
  inline ::std::string* release_effective_user();
  inline void set_allocated_effective_user(::std::string* effective_user);

  // required string real_user = 2;
  inline bool has_real_user() const;
  inline void clear_real_user();
  static const int kRealUserFieldNumber = 2;
  inline const ::std::string& real_user() const;
  inline void set_real_user(const ::std::string& value);
  inline void set_real_user(const char* value);
  inline void set_real_user(const char* value, size_t size);
  inline ::std::string* mutable_real_user();
  inline ::std::string* release_real_user();
  inline void set_allocated_real_user(::std::string* real_user);

  // @@protoc_insertion_point(class_scope:base.rpc.UserInformationPB)
 private:
  inline void set_has_effective_user();
  inline void clear_has_effective_user();
  inline void set_has_real_user();
  inline void clear_has_real_user();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* effective_user_;
  ::std::string* real_user_;
  friend void  protobuf_AddDesc_base_2frpc_2frpc_5fheader_2eproto();
  friend void protobuf_AssignDesc_base_2frpc_2frpc_5fheader_2eproto();
  friend void protobuf_ShutdownFile_base_2frpc_2frpc_5fheader_2eproto();

  void InitAsDefaultInstance();
  static UserInformationPB* default_instance_;
};
// -------------------------------------------------------------------

class ConnectionContextPB : public ::google::protobuf::Message {
 public:
  ConnectionContextPB();
  virtual ~ConnectionContextPB();

  ConnectionContextPB(const ConnectionContextPB& from);

  inline ConnectionContextPB& operator=(const ConnectionContextPB& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ConnectionContextPB& default_instance();

  void Swap(ConnectionContextPB* other);

  // implements Message ----------------------------------------------

  ConnectionContextPB* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ConnectionContextPB& from);
  void MergeFrom(const ConnectionContextPB& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .base.rpc.UserInformationPB DEPRECATED_user_info = 2;
  inline bool has_deprecated_user_info() const;
  inline void clear_deprecated_user_info();
  static const int kDEPRECATEDUserInfoFieldNumber = 2;
  inline const ::base::rpc::UserInformationPB& deprecated_user_info() const;
  inline ::base::rpc::UserInformationPB* mutable_deprecated_user_info();
  inline ::base::rpc::UserInformationPB* release_deprecated_user_info();
  inline void set_allocated_deprecated_user_info(::base::rpc::UserInformationPB* deprecated_user_info);

  // @@protoc_insertion_point(class_scope:base.rpc.ConnectionContextPB)
 private:
  inline void set_has_deprecated_user_info();
  inline void clear_has_deprecated_user_info();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::base::rpc::UserInformationPB* deprecated_user_info_;
  friend void  protobuf_AddDesc_base_2frpc_2frpc_5fheader_2eproto();
  friend void protobuf_AssignDesc_base_2frpc_2frpc_5fheader_2eproto();
  friend void protobuf_ShutdownFile_base_2frpc_2frpc_5fheader_2eproto();

  void InitAsDefaultInstance();
  static ConnectionContextPB* default_instance_;
};
// -------------------------------------------------------------------

class SaslMessagePB_SaslAuth : public ::google::protobuf::Message {
 public:
  SaslMessagePB_SaslAuth();
  virtual ~SaslMessagePB_SaslAuth();

  SaslMessagePB_SaslAuth(const SaslMessagePB_SaslAuth& from);

  inline SaslMessagePB_SaslAuth& operator=(const SaslMessagePB_SaslAuth& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SaslMessagePB_SaslAuth& default_instance();

  void Swap(SaslMessagePB_SaslAuth* other);

  // implements Message ----------------------------------------------

  SaslMessagePB_SaslAuth* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SaslMessagePB_SaslAuth& from);
  void MergeFrom(const SaslMessagePB_SaslAuth& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string method = 1;
  inline bool has_method() const;
  inline void clear_method();
  static const int kMethodFieldNumber = 1;
  inline const ::std::string& method() const;
  inline void set_method(const ::std::string& value);
  inline void set_method(const char* value);
  inline void set_method(const char* value, size_t size);
  inline ::std::string* mutable_method();
  inline ::std::string* release_method();
  inline void set_allocated_method(::std::string* method);

  // required string mechanism = 2;
  inline bool has_mechanism() const;
  inline void clear_mechanism();
  static const int kMechanismFieldNumber = 2;
  inline const ::std::string& mechanism() const;
  inline void set_mechanism(const ::std::string& value);
  inline void set_mechanism(const char* value);
  inline void set_mechanism(const char* value, size_t size);
  inline ::std::string* mutable_mechanism();
  inline ::std::string* release_mechanism();
  inline void set_allocated_mechanism(::std::string* mechanism);

  // optional bytes challenge = 5;
  inline bool has_challenge() const;
  inline void clear_challenge();
  static const int kChallengeFieldNumber = 5;
  inline const ::std::string& challenge() const;
  inline void set_challenge(const ::std::string& value);
  inline void set_challenge(const char* value);
  inline void set_challenge(const void* value, size_t size);
  inline ::std::string* mutable_challenge();
  inline ::std::string* release_challenge();
  inline void set_allocated_challenge(::std::string* challenge);

  // @@protoc_insertion_point(class_scope:base.rpc.SaslMessagePB.SaslAuth)
 private:
  inline void set_has_method();
  inline void clear_has_method();
  inline void set_has_mechanism();
  inline void clear_has_mechanism();
  inline void set_has_challenge();
  inline void clear_has_challenge();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* method_;
  ::std::string* mechanism_;
  ::std::string* challenge_;
  friend void  protobuf_AddDesc_base_2frpc_2frpc_5fheader_2eproto();
  friend void protobuf_AssignDesc_base_2frpc_2frpc_5fheader_2eproto();
  friend void protobuf_ShutdownFile_base_2frpc_2frpc_5fheader_2eproto();

  void InitAsDefaultInstance();
  static SaslMessagePB_SaslAuth* default_instance_;
};
// -------------------------------------------------------------------

class SaslMessagePB : public ::google::protobuf::Message {
 public:
  SaslMessagePB();
  virtual ~SaslMessagePB();

  SaslMessagePB(const SaslMessagePB& from);

  inline SaslMessagePB& operator=(const SaslMessagePB& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SaslMessagePB& default_instance();

  void Swap(SaslMessagePB* other);

  // implements Message ----------------------------------------------

  SaslMessagePB* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SaslMessagePB& from);
  void MergeFrom(const SaslMessagePB& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef SaslMessagePB_SaslAuth SaslAuth;

  typedef SaslMessagePB_SaslState SaslState;
  static const SaslState UNKNOWN = SaslMessagePB_SaslState_UNKNOWN;
  static const SaslState SUCCESS = SaslMessagePB_SaslState_SUCCESS;
  static const SaslState NEGOTIATE = SaslMessagePB_SaslState_NEGOTIATE;
  static const SaslState INITIATE = SaslMessagePB_SaslState_INITIATE;
  static const SaslState CHALLENGE = SaslMessagePB_SaslState_CHALLENGE;
  static const SaslState RESPONSE = SaslMessagePB_SaslState_RESPONSE;
  static inline bool SaslState_IsValid(int value) {
    return SaslMessagePB_SaslState_IsValid(value);
  }
  static const SaslState SaslState_MIN =
    SaslMessagePB_SaslState_SaslState_MIN;
  static const SaslState SaslState_MAX =
    SaslMessagePB_SaslState_SaslState_MAX;
  static const int SaslState_ARRAYSIZE =
    SaslMessagePB_SaslState_SaslState_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  SaslState_descriptor() {
    return SaslMessagePB_SaslState_descriptor();
  }
  static inline const ::std::string& SaslState_Name(SaslState value) {
    return SaslMessagePB_SaslState_Name(value);
  }
  static inline bool SaslState_Parse(const ::std::string& name,
      SaslState* value) {
    return SaslMessagePB_SaslState_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // repeated .base.rpc.RpcFeatureFlag supported_features = 1;
  inline int supported_features_size() const;
  inline void clear_supported_features();
  static const int kSupportedFeaturesFieldNumber = 1;
  inline ::base::rpc::RpcFeatureFlag supported_features(int index) const;
  inline void set_supported_features(int index, ::base::rpc::RpcFeatureFlag value);
  inline void add_supported_features(::base::rpc::RpcFeatureFlag value);
  inline const ::google::protobuf::RepeatedField<int>& supported_features() const;
  inline ::google::protobuf::RepeatedField<int>* mutable_supported_features();

  // required .base.rpc.SaslMessagePB.SaslState state = 2;
  inline bool has_state() const;
  inline void clear_state();
  static const int kStateFieldNumber = 2;
  inline ::base::rpc::SaslMessagePB_SaslState state() const;
  inline void set_state(::base::rpc::SaslMessagePB_SaslState value);

  // optional bytes token = 3;
  inline bool has_token() const;
  inline void clear_token();
  static const int kTokenFieldNumber = 3;
  inline const ::std::string& token() const;
  inline void set_token(const ::std::string& value);
  inline void set_token(const char* value);
  inline void set_token(const void* value, size_t size);
  inline ::std::string* mutable_token();
  inline ::std::string* release_token();
  inline void set_allocated_token(::std::string* token);

  // repeated .base.rpc.SaslMessagePB.SaslAuth auths = 4;
  inline int auths_size() const;
  inline void clear_auths();
  static const int kAuthsFieldNumber = 4;
  inline const ::base::rpc::SaslMessagePB_SaslAuth& auths(int index) const;
  inline ::base::rpc::SaslMessagePB_SaslAuth* mutable_auths(int index);
  inline ::base::rpc::SaslMessagePB_SaslAuth* add_auths();
  inline const ::google::protobuf::RepeatedPtrField< ::base::rpc::SaslMessagePB_SaslAuth >&
      auths() const;
  inline ::google::protobuf::RepeatedPtrField< ::base::rpc::SaslMessagePB_SaslAuth >*
      mutable_auths();

  // @@protoc_insertion_point(class_scope:base.rpc.SaslMessagePB)
 private:
  inline void set_has_state();
  inline void clear_has_state();
  inline void set_has_token();
  inline void clear_has_token();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedField<int> supported_features_;
  ::std::string* token_;
  ::google::protobuf::RepeatedPtrField< ::base::rpc::SaslMessagePB_SaslAuth > auths_;
  int state_;
  friend void  protobuf_AddDesc_base_2frpc_2frpc_5fheader_2eproto();
  friend void protobuf_AssignDesc_base_2frpc_2frpc_5fheader_2eproto();
  friend void protobuf_ShutdownFile_base_2frpc_2frpc_5fheader_2eproto();

  void InitAsDefaultInstance();
  static SaslMessagePB* default_instance_;
};
// -------------------------------------------------------------------

class RemoteMethodPB : public ::google::protobuf::Message {
 public:
  RemoteMethodPB();
  virtual ~RemoteMethodPB();

  RemoteMethodPB(const RemoteMethodPB& from);

  inline RemoteMethodPB& operator=(const RemoteMethodPB& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RemoteMethodPB& default_instance();

  void Swap(RemoteMethodPB* other);

  // implements Message ----------------------------------------------

  RemoteMethodPB* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RemoteMethodPB& from);
  void MergeFrom(const RemoteMethodPB& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string service_name = 1;
  inline bool has_service_name() const;
  inline void clear_service_name();
  static const int kServiceNameFieldNumber = 1;
  inline const ::std::string& service_name() const;
  inline void set_service_name(const ::std::string& value);
  inline void set_service_name(const char* value);
  inline void set_service_name(const char* value, size_t size);
  inline ::std::string* mutable_service_name();
  inline ::std::string* release_service_name();
  inline void set_allocated_service_name(::std::string* service_name);

  // required string method_name = 2;
  inline bool has_method_name() const;
  inline void clear_method_name();
  static const int kMethodNameFieldNumber = 2;
  inline const ::std::string& method_name() const;
  inline void set_method_name(const ::std::string& value);
  inline void set_method_name(const char* value);
  inline void set_method_name(const char* value, size_t size);
  inline ::std::string* mutable_method_name();
  inline ::std::string* release_method_name();
  inline void set_allocated_method_name(::std::string* method_name);

  // @@protoc_insertion_point(class_scope:base.rpc.RemoteMethodPB)
 private:
  inline void set_has_service_name();
  inline void clear_has_service_name();
  inline void set_has_method_name();
  inline void clear_has_method_name();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* service_name_;
  ::std::string* method_name_;
  friend void  protobuf_AddDesc_base_2frpc_2frpc_5fheader_2eproto();
  friend void protobuf_AssignDesc_base_2frpc_2frpc_5fheader_2eproto();
  friend void protobuf_ShutdownFile_base_2frpc_2frpc_5fheader_2eproto();

  void InitAsDefaultInstance();
  static RemoteMethodPB* default_instance_;
};
// -------------------------------------------------------------------

class RequestIdPB : public ::google::protobuf::Message {
 public:
  RequestIdPB();
  virtual ~RequestIdPB();

  RequestIdPB(const RequestIdPB& from);

  inline RequestIdPB& operator=(const RequestIdPB& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RequestIdPB& default_instance();

  void Swap(RequestIdPB* other);

  // implements Message ----------------------------------------------

  RequestIdPB* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RequestIdPB& from);
  void MergeFrom(const RequestIdPB& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string client_id = 1;
  inline bool has_client_id() const;
  inline void clear_client_id();
  static const int kClientIdFieldNumber = 1;
  inline const ::std::string& client_id() const;
  inline void set_client_id(const ::std::string& value);
  inline void set_client_id(const char* value);
  inline void set_client_id(const char* value, size_t size);
  inline ::std::string* mutable_client_id();
  inline ::std::string* release_client_id();
  inline void set_allocated_client_id(::std::string* client_id);

  // required int64 seq_no = 2;
  inline bool has_seq_no() const;
  inline void clear_seq_no();
  static const int kSeqNoFieldNumber = 2;
  inline ::google::protobuf::int64 seq_no() const;
  inline void set_seq_no(::google::protobuf::int64 value);

  // required int64 first_incomplete_seq_no = 3;
  inline bool has_first_incomplete_seq_no() const;
  inline void clear_first_incomplete_seq_no();
  static const int kFirstIncompleteSeqNoFieldNumber = 3;
  inline ::google::protobuf::int64 first_incomplete_seq_no() const;
  inline void set_first_incomplete_seq_no(::google::protobuf::int64 value);

  // required int64 attempt_no = 4;
  inline bool has_attempt_no() const;
  inline void clear_attempt_no();
  static const int kAttemptNoFieldNumber = 4;
  inline ::google::protobuf::int64 attempt_no() const;
  inline void set_attempt_no(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:base.rpc.RequestIdPB)
 private:
  inline void set_has_client_id();
  inline void clear_has_client_id();
  inline void set_has_seq_no();
  inline void clear_has_seq_no();
  inline void set_has_first_incomplete_seq_no();
  inline void clear_has_first_incomplete_seq_no();
  inline void set_has_attempt_no();
  inline void clear_has_attempt_no();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* client_id_;
  ::google::protobuf::int64 seq_no_;
  ::google::protobuf::int64 first_incomplete_seq_no_;
  ::google::protobuf::int64 attempt_no_;
  friend void  protobuf_AddDesc_base_2frpc_2frpc_5fheader_2eproto();
  friend void protobuf_AssignDesc_base_2frpc_2frpc_5fheader_2eproto();
  friend void protobuf_ShutdownFile_base_2frpc_2frpc_5fheader_2eproto();

  void InitAsDefaultInstance();
  static RequestIdPB* default_instance_;
};
// -------------------------------------------------------------------

class RequestHeader : public ::google::protobuf::Message {
 public:
  RequestHeader();
  virtual ~RequestHeader();

  RequestHeader(const RequestHeader& from);

  inline RequestHeader& operator=(const RequestHeader& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RequestHeader& default_instance();

  void Swap(RequestHeader* other);

  // implements Message ----------------------------------------------

  RequestHeader* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RequestHeader& from);
  void MergeFrom(const RequestHeader& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 call_id = 3;
  inline bool has_call_id() const;
  inline void clear_call_id();
  static const int kCallIdFieldNumber = 3;
  inline ::google::protobuf::int32 call_id() const;
  inline void set_call_id(::google::protobuf::int32 value);

  // optional .base.rpc.RemoteMethodPB remote_method = 6;
  inline bool has_remote_method() const;
  inline void clear_remote_method();
  static const int kRemoteMethodFieldNumber = 6;
  inline const ::base::rpc::RemoteMethodPB& remote_method() const;
  inline ::base::rpc::RemoteMethodPB* mutable_remote_method();
  inline ::base::rpc::RemoteMethodPB* release_remote_method();
  inline void set_allocated_remote_method(::base::rpc::RemoteMethodPB* remote_method);

  // optional uint32 timeout_millis = 10;
  inline bool has_timeout_millis() const;
  inline void clear_timeout_millis();
  static const int kTimeoutMillisFieldNumber = 10;
  inline ::google::protobuf::uint32 timeout_millis() const;
  inline void set_timeout_millis(::google::protobuf::uint32 value);

  // repeated uint32 required_feature_flags = 11;
  inline int required_feature_flags_size() const;
  inline void clear_required_feature_flags();
  static const int kRequiredFeatureFlagsFieldNumber = 11;
  inline ::google::protobuf::uint32 required_feature_flags(int index) const;
  inline void set_required_feature_flags(int index, ::google::protobuf::uint32 value);
  inline void add_required_feature_flags(::google::protobuf::uint32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
      required_feature_flags() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
      mutable_required_feature_flags();

  // optional .base.rpc.RequestIdPB request_id = 15;
  inline bool has_request_id() const;
  inline void clear_request_id();
  static const int kRequestIdFieldNumber = 15;
  inline const ::base::rpc::RequestIdPB& request_id() const;
  inline ::base::rpc::RequestIdPB* mutable_request_id();
  inline ::base::rpc::RequestIdPB* release_request_id();
  inline void set_allocated_request_id(::base::rpc::RequestIdPB* request_id);

  // @@protoc_insertion_point(class_scope:base.rpc.RequestHeader)
 private:
  inline void set_has_call_id();
  inline void clear_has_call_id();
  inline void set_has_remote_method();
  inline void clear_has_remote_method();
  inline void set_has_timeout_millis();
  inline void clear_has_timeout_millis();
  inline void set_has_request_id();
  inline void clear_has_request_id();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::base::rpc::RemoteMethodPB* remote_method_;
  ::google::protobuf::int32 call_id_;
  ::google::protobuf::uint32 timeout_millis_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 > required_feature_flags_;
  ::base::rpc::RequestIdPB* request_id_;
  friend void  protobuf_AddDesc_base_2frpc_2frpc_5fheader_2eproto();
  friend void protobuf_AssignDesc_base_2frpc_2frpc_5fheader_2eproto();
  friend void protobuf_ShutdownFile_base_2frpc_2frpc_5fheader_2eproto();

  void InitAsDefaultInstance();
  static RequestHeader* default_instance_;
};
// -------------------------------------------------------------------

class ResponseHeader : public ::google::protobuf::Message {
 public:
  ResponseHeader();
  virtual ~ResponseHeader();

  ResponseHeader(const ResponseHeader& from);

  inline ResponseHeader& operator=(const ResponseHeader& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ResponseHeader& default_instance();

  void Swap(ResponseHeader* other);

  // implements Message ----------------------------------------------

  ResponseHeader* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ResponseHeader& from);
  void MergeFrom(const ResponseHeader& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 call_id = 1;
  inline bool has_call_id() const;
  inline void clear_call_id();
  static const int kCallIdFieldNumber = 1;
  inline ::google::protobuf::int32 call_id() const;
  inline void set_call_id(::google::protobuf::int32 value);

  // optional bool is_error = 2 [default = false];
  inline bool has_is_error() const;
  inline void clear_is_error();
  static const int kIsErrorFieldNumber = 2;
  inline bool is_error() const;
  inline void set_is_error(bool value);

  // repeated uint32 sidecar_offsets = 3;
  inline int sidecar_offsets_size() const;
  inline void clear_sidecar_offsets();
  static const int kSidecarOffsetsFieldNumber = 3;
  inline ::google::protobuf::uint32 sidecar_offsets(int index) const;
  inline void set_sidecar_offsets(int index, ::google::protobuf::uint32 value);
  inline void add_sidecar_offsets(::google::protobuf::uint32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
      sidecar_offsets() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
      mutable_sidecar_offsets();

  // @@protoc_insertion_point(class_scope:base.rpc.ResponseHeader)
 private:
  inline void set_has_call_id();
  inline void clear_has_call_id();
  inline void set_has_is_error();
  inline void clear_has_is_error();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::int32 call_id_;
  bool is_error_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 > sidecar_offsets_;
  friend void  protobuf_AddDesc_base_2frpc_2frpc_5fheader_2eproto();
  friend void protobuf_AssignDesc_base_2frpc_2frpc_5fheader_2eproto();
  friend void protobuf_ShutdownFile_base_2frpc_2frpc_5fheader_2eproto();

  void InitAsDefaultInstance();
  static ResponseHeader* default_instance_;
};
// -------------------------------------------------------------------

class ErrorStatusPB : public ::google::protobuf::Message {
 public:
  ErrorStatusPB();
  virtual ~ErrorStatusPB();

  ErrorStatusPB(const ErrorStatusPB& from);

  inline ErrorStatusPB& operator=(const ErrorStatusPB& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ErrorStatusPB& default_instance();

  void Swap(ErrorStatusPB* other);

  // implements Message ----------------------------------------------

  ErrorStatusPB* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ErrorStatusPB& from);
  void MergeFrom(const ErrorStatusPB& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef ErrorStatusPB_RpcErrorCodePB RpcErrorCodePB;
  static const RpcErrorCodePB FATAL_UNKNOWN = ErrorStatusPB_RpcErrorCodePB_FATAL_UNKNOWN;
  static const RpcErrorCodePB ERROR_APPLICATION = ErrorStatusPB_RpcErrorCodePB_ERROR_APPLICATION;
  static const RpcErrorCodePB ERROR_NO_SUCH_METHOD = ErrorStatusPB_RpcErrorCodePB_ERROR_NO_SUCH_METHOD;
  static const RpcErrorCodePB ERROR_NO_SUCH_SERVICE = ErrorStatusPB_RpcErrorCodePB_ERROR_NO_SUCH_SERVICE;
  static const RpcErrorCodePB ERROR_SERVER_TOO_BUSY = ErrorStatusPB_RpcErrorCodePB_ERROR_SERVER_TOO_BUSY;
  static const RpcErrorCodePB ERROR_INVALID_REQUEST = ErrorStatusPB_RpcErrorCodePB_ERROR_INVALID_REQUEST;
  static const RpcErrorCodePB ERROR_REQUEST_STALE = ErrorStatusPB_RpcErrorCodePB_ERROR_REQUEST_STALE;
  static const RpcErrorCodePB FATAL_SERVER_SHUTTING_DOWN = ErrorStatusPB_RpcErrorCodePB_FATAL_SERVER_SHUTTING_DOWN;
  static const RpcErrorCodePB FATAL_INVALID_RPC_HEADER = ErrorStatusPB_RpcErrorCodePB_FATAL_INVALID_RPC_HEADER;
  static const RpcErrorCodePB FATAL_DESERIALIZING_REQUEST = ErrorStatusPB_RpcErrorCodePB_FATAL_DESERIALIZING_REQUEST;
  static const RpcErrorCodePB FATAL_VERSION_MISMATCH = ErrorStatusPB_RpcErrorCodePB_FATAL_VERSION_MISMATCH;
  static const RpcErrorCodePB FATAL_UNAUTHORIZED = ErrorStatusPB_RpcErrorCodePB_FATAL_UNAUTHORIZED;
  static inline bool RpcErrorCodePB_IsValid(int value) {
    return ErrorStatusPB_RpcErrorCodePB_IsValid(value);
  }
  static const RpcErrorCodePB RpcErrorCodePB_MIN =
    ErrorStatusPB_RpcErrorCodePB_RpcErrorCodePB_MIN;
  static const RpcErrorCodePB RpcErrorCodePB_MAX =
    ErrorStatusPB_RpcErrorCodePB_RpcErrorCodePB_MAX;
  static const int RpcErrorCodePB_ARRAYSIZE =
    ErrorStatusPB_RpcErrorCodePB_RpcErrorCodePB_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  RpcErrorCodePB_descriptor() {
    return ErrorStatusPB_RpcErrorCodePB_descriptor();
  }
  static inline const ::std::string& RpcErrorCodePB_Name(RpcErrorCodePB value) {
    return ErrorStatusPB_RpcErrorCodePB_Name(value);
  }
  static inline bool RpcErrorCodePB_Parse(const ::std::string& name,
      RpcErrorCodePB* value) {
    return ErrorStatusPB_RpcErrorCodePB_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // required string message = 1;
  inline bool has_message() const;
  inline void clear_message();
  static const int kMessageFieldNumber = 1;
  inline const ::std::string& message() const;
  inline void set_message(const ::std::string& value);
  inline void set_message(const char* value);
  inline void set_message(const char* value, size_t size);
  inline ::std::string* mutable_message();
  inline ::std::string* release_message();
  inline void set_allocated_message(::std::string* message);

  // optional .base.rpc.ErrorStatusPB.RpcErrorCodePB code = 2;
  inline bool has_code() const;
  inline void clear_code();
  static const int kCodeFieldNumber = 2;
  inline ::base::rpc::ErrorStatusPB_RpcErrorCodePB code() const;
  inline void set_code(::base::rpc::ErrorStatusPB_RpcErrorCodePB value);

  // repeated uint32 unsupported_feature_flags = 3;
  inline int unsupported_feature_flags_size() const;
  inline void clear_unsupported_feature_flags();
  static const int kUnsupportedFeatureFlagsFieldNumber = 3;
  inline ::google::protobuf::uint32 unsupported_feature_flags(int index) const;
  inline void set_unsupported_feature_flags(int index, ::google::protobuf::uint32 value);
  inline void add_unsupported_feature_flags(::google::protobuf::uint32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
      unsupported_feature_flags() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
      mutable_unsupported_feature_flags();

  GOOGLE_PROTOBUF_EXTENSION_ACCESSORS(ErrorStatusPB)
  // @@protoc_insertion_point(class_scope:base.rpc.ErrorStatusPB)
 private:
  inline void set_has_message();
  inline void clear_has_message();
  inline void set_has_code();
  inline void clear_has_code();

  ::google::protobuf::internal::ExtensionSet _extensions_;

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* message_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 > unsupported_feature_flags_;
  int code_;
  friend void  protobuf_AddDesc_base_2frpc_2frpc_5fheader_2eproto();
  friend void protobuf_AssignDesc_base_2frpc_2frpc_5fheader_2eproto();
  friend void protobuf_ShutdownFile_base_2frpc_2frpc_5fheader_2eproto();

  void InitAsDefaultInstance();
  static ErrorStatusPB* default_instance_;
};
// ===================================================================

static const int kTrackRpcResultFieldNumber = 50006;
extern ::google::protobuf::internal::ExtensionIdentifier< ::google::protobuf::MethodOptions,
    ::google::protobuf::internal::PrimitiveTypeTraits< bool >, 8, false >
  track_rpc_result;

// ===================================================================

// UserInformationPB

// optional string effective_user = 1;
inline bool UserInformationPB::has_effective_user() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void UserInformationPB::set_has_effective_user() {
  _has_bits_[0] |= 0x00000001u;
}
inline void UserInformationPB::clear_has_effective_user() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void UserInformationPB::clear_effective_user() {
  if (effective_user_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    effective_user_->clear();
  }
  clear_has_effective_user();
}
inline const ::std::string& UserInformationPB::effective_user() const {
  // @@protoc_insertion_point(field_get:base.rpc.UserInformationPB.effective_user)
  return *effective_user_;
}
inline void UserInformationPB::set_effective_user(const ::std::string& value) {
  set_has_effective_user();
  if (effective_user_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    effective_user_ = new ::std::string;
  }
  effective_user_->assign(value);
  // @@protoc_insertion_point(field_set:base.rpc.UserInformationPB.effective_user)
}
inline void UserInformationPB::set_effective_user(const char* value) {
  set_has_effective_user();
  if (effective_user_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    effective_user_ = new ::std::string;
  }
  effective_user_->assign(value);
  // @@protoc_insertion_point(field_set_char:base.rpc.UserInformationPB.effective_user)
}
inline void UserInformationPB::set_effective_user(const char* value, size_t size) {
  set_has_effective_user();
  if (effective_user_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    effective_user_ = new ::std::string;
  }
  effective_user_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:base.rpc.UserInformationPB.effective_user)
}
inline ::std::string* UserInformationPB::mutable_effective_user() {
  set_has_effective_user();
  if (effective_user_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    effective_user_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:base.rpc.UserInformationPB.effective_user)
  return effective_user_;
}
inline ::std::string* UserInformationPB::release_effective_user() {
  clear_has_effective_user();
  if (effective_user_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = effective_user_;
    effective_user_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void UserInformationPB::set_allocated_effective_user(::std::string* effective_user) {
  if (effective_user_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete effective_user_;
  }
  if (effective_user) {
    set_has_effective_user();
    effective_user_ = effective_user;
  } else {
    clear_has_effective_user();
    effective_user_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:base.rpc.UserInformationPB.effective_user)
}

// required string real_user = 2;
inline bool UserInformationPB::has_real_user() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void UserInformationPB::set_has_real_user() {
  _has_bits_[0] |= 0x00000002u;
}
inline void UserInformationPB::clear_has_real_user() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void UserInformationPB::clear_real_user() {
  if (real_user_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    real_user_->clear();
  }
  clear_has_real_user();
}
inline const ::std::string& UserInformationPB::real_user() const {
  // @@protoc_insertion_point(field_get:base.rpc.UserInformationPB.real_user)
  return *real_user_;
}
inline void UserInformationPB::set_real_user(const ::std::string& value) {
  set_has_real_user();
  if (real_user_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    real_user_ = new ::std::string;
  }
  real_user_->assign(value);
  // @@protoc_insertion_point(field_set:base.rpc.UserInformationPB.real_user)
}
inline void UserInformationPB::set_real_user(const char* value) {
  set_has_real_user();
  if (real_user_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    real_user_ = new ::std::string;
  }
  real_user_->assign(value);
  // @@protoc_insertion_point(field_set_char:base.rpc.UserInformationPB.real_user)
}
inline void UserInformationPB::set_real_user(const char* value, size_t size) {
  set_has_real_user();
  if (real_user_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    real_user_ = new ::std::string;
  }
  real_user_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:base.rpc.UserInformationPB.real_user)
}
inline ::std::string* UserInformationPB::mutable_real_user() {
  set_has_real_user();
  if (real_user_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    real_user_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:base.rpc.UserInformationPB.real_user)
  return real_user_;
}
inline ::std::string* UserInformationPB::release_real_user() {
  clear_has_real_user();
  if (real_user_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = real_user_;
    real_user_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void UserInformationPB::set_allocated_real_user(::std::string* real_user) {
  if (real_user_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete real_user_;
  }
  if (real_user) {
    set_has_real_user();
    real_user_ = real_user;
  } else {
    clear_has_real_user();
    real_user_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:base.rpc.UserInformationPB.real_user)
}

// -------------------------------------------------------------------

// ConnectionContextPB

// optional .base.rpc.UserInformationPB DEPRECATED_user_info = 2;
inline bool ConnectionContextPB::has_deprecated_user_info() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ConnectionContextPB::set_has_deprecated_user_info() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ConnectionContextPB::clear_has_deprecated_user_info() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ConnectionContextPB::clear_deprecated_user_info() {
  if (deprecated_user_info_ != NULL) deprecated_user_info_->::base::rpc::UserInformationPB::Clear();
  clear_has_deprecated_user_info();
}
inline const ::base::rpc::UserInformationPB& ConnectionContextPB::deprecated_user_info() const {
  // @@protoc_insertion_point(field_get:base.rpc.ConnectionContextPB.DEPRECATED_user_info)
  return deprecated_user_info_ != NULL ? *deprecated_user_info_ : *default_instance_->deprecated_user_info_;
}
inline ::base::rpc::UserInformationPB* ConnectionContextPB::mutable_deprecated_user_info() {
  set_has_deprecated_user_info();
  if (deprecated_user_info_ == NULL) deprecated_user_info_ = new ::base::rpc::UserInformationPB;
  // @@protoc_insertion_point(field_mutable:base.rpc.ConnectionContextPB.DEPRECATED_user_info)
  return deprecated_user_info_;
}
inline ::base::rpc::UserInformationPB* ConnectionContextPB::release_deprecated_user_info() {
  clear_has_deprecated_user_info();
  ::base::rpc::UserInformationPB* temp = deprecated_user_info_;
  deprecated_user_info_ = NULL;
  return temp;
}
inline void ConnectionContextPB::set_allocated_deprecated_user_info(::base::rpc::UserInformationPB* deprecated_user_info) {
  delete deprecated_user_info_;
  deprecated_user_info_ = deprecated_user_info;
  if (deprecated_user_info) {
    set_has_deprecated_user_info();
  } else {
    clear_has_deprecated_user_info();
  }
  // @@protoc_insertion_point(field_set_allocated:base.rpc.ConnectionContextPB.DEPRECATED_user_info)
}

// -------------------------------------------------------------------

// SaslMessagePB_SaslAuth

// optional string method = 1;
inline bool SaslMessagePB_SaslAuth::has_method() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SaslMessagePB_SaslAuth::set_has_method() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SaslMessagePB_SaslAuth::clear_has_method() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SaslMessagePB_SaslAuth::clear_method() {
  if (method_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    method_->clear();
  }
  clear_has_method();
}
inline const ::std::string& SaslMessagePB_SaslAuth::method() const {
  // @@protoc_insertion_point(field_get:base.rpc.SaslMessagePB.SaslAuth.method)
  return *method_;
}
inline void SaslMessagePB_SaslAuth::set_method(const ::std::string& value) {
  set_has_method();
  if (method_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    method_ = new ::std::string;
  }
  method_->assign(value);
  // @@protoc_insertion_point(field_set:base.rpc.SaslMessagePB.SaslAuth.method)
}
inline void SaslMessagePB_SaslAuth::set_method(const char* value) {
  set_has_method();
  if (method_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    method_ = new ::std::string;
  }
  method_->assign(value);
  // @@protoc_insertion_point(field_set_char:base.rpc.SaslMessagePB.SaslAuth.method)
}
inline void SaslMessagePB_SaslAuth::set_method(const char* value, size_t size) {
  set_has_method();
  if (method_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    method_ = new ::std::string;
  }
  method_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:base.rpc.SaslMessagePB.SaslAuth.method)
}
inline ::std::string* SaslMessagePB_SaslAuth::mutable_method() {
  set_has_method();
  if (method_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    method_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:base.rpc.SaslMessagePB.SaslAuth.method)
  return method_;
}
inline ::std::string* SaslMessagePB_SaslAuth::release_method() {
  clear_has_method();
  if (method_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = method_;
    method_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void SaslMessagePB_SaslAuth::set_allocated_method(::std::string* method) {
  if (method_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete method_;
  }
  if (method) {
    set_has_method();
    method_ = method;
  } else {
    clear_has_method();
    method_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:base.rpc.SaslMessagePB.SaslAuth.method)
}

// required string mechanism = 2;
inline bool SaslMessagePB_SaslAuth::has_mechanism() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SaslMessagePB_SaslAuth::set_has_mechanism() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SaslMessagePB_SaslAuth::clear_has_mechanism() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SaslMessagePB_SaslAuth::clear_mechanism() {
  if (mechanism_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    mechanism_->clear();
  }
  clear_has_mechanism();
}
inline const ::std::string& SaslMessagePB_SaslAuth::mechanism() const {
  // @@protoc_insertion_point(field_get:base.rpc.SaslMessagePB.SaslAuth.mechanism)
  return *mechanism_;
}
inline void SaslMessagePB_SaslAuth::set_mechanism(const ::std::string& value) {
  set_has_mechanism();
  if (mechanism_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    mechanism_ = new ::std::string;
  }
  mechanism_->assign(value);
  // @@protoc_insertion_point(field_set:base.rpc.SaslMessagePB.SaslAuth.mechanism)
}
inline void SaslMessagePB_SaslAuth::set_mechanism(const char* value) {
  set_has_mechanism();
  if (mechanism_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    mechanism_ = new ::std::string;
  }
  mechanism_->assign(value);
  // @@protoc_insertion_point(field_set_char:base.rpc.SaslMessagePB.SaslAuth.mechanism)
}
inline void SaslMessagePB_SaslAuth::set_mechanism(const char* value, size_t size) {
  set_has_mechanism();
  if (mechanism_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    mechanism_ = new ::std::string;
  }
  mechanism_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:base.rpc.SaslMessagePB.SaslAuth.mechanism)
}
inline ::std::string* SaslMessagePB_SaslAuth::mutable_mechanism() {
  set_has_mechanism();
  if (mechanism_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    mechanism_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:base.rpc.SaslMessagePB.SaslAuth.mechanism)
  return mechanism_;
}
inline ::std::string* SaslMessagePB_SaslAuth::release_mechanism() {
  clear_has_mechanism();
  if (mechanism_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = mechanism_;
    mechanism_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void SaslMessagePB_SaslAuth::set_allocated_mechanism(::std::string* mechanism) {
  if (mechanism_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete mechanism_;
  }
  if (mechanism) {
    set_has_mechanism();
    mechanism_ = mechanism;
  } else {
    clear_has_mechanism();
    mechanism_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:base.rpc.SaslMessagePB.SaslAuth.mechanism)
}

// optional bytes challenge = 5;
inline bool SaslMessagePB_SaslAuth::has_challenge() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void SaslMessagePB_SaslAuth::set_has_challenge() {
  _has_bits_[0] |= 0x00000004u;
}
inline void SaslMessagePB_SaslAuth::clear_has_challenge() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void SaslMessagePB_SaslAuth::clear_challenge() {
  if (challenge_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    challenge_->clear();
  }
  clear_has_challenge();
}
inline const ::std::string& SaslMessagePB_SaslAuth::challenge() const {
  // @@protoc_insertion_point(field_get:base.rpc.SaslMessagePB.SaslAuth.challenge)
  return *challenge_;
}
inline void SaslMessagePB_SaslAuth::set_challenge(const ::std::string& value) {
  set_has_challenge();
  if (challenge_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    challenge_ = new ::std::string;
  }
  challenge_->assign(value);
  // @@protoc_insertion_point(field_set:base.rpc.SaslMessagePB.SaslAuth.challenge)
}
inline void SaslMessagePB_SaslAuth::set_challenge(const char* value) {
  set_has_challenge();
  if (challenge_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    challenge_ = new ::std::string;
  }
  challenge_->assign(value);
  // @@protoc_insertion_point(field_set_char:base.rpc.SaslMessagePB.SaslAuth.challenge)
}
inline void SaslMessagePB_SaslAuth::set_challenge(const void* value, size_t size) {
  set_has_challenge();
  if (challenge_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    challenge_ = new ::std::string;
  }
  challenge_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:base.rpc.SaslMessagePB.SaslAuth.challenge)
}
inline ::std::string* SaslMessagePB_SaslAuth::mutable_challenge() {
  set_has_challenge();
  if (challenge_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    challenge_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:base.rpc.SaslMessagePB.SaslAuth.challenge)
  return challenge_;
}
inline ::std::string* SaslMessagePB_SaslAuth::release_challenge() {
  clear_has_challenge();
  if (challenge_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = challenge_;
    challenge_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void SaslMessagePB_SaslAuth::set_allocated_challenge(::std::string* challenge) {
  if (challenge_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete challenge_;
  }
  if (challenge) {
    set_has_challenge();
    challenge_ = challenge;
  } else {
    clear_has_challenge();
    challenge_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:base.rpc.SaslMessagePB.SaslAuth.challenge)
}

// -------------------------------------------------------------------

// SaslMessagePB

// repeated .base.rpc.RpcFeatureFlag supported_features = 1;
inline int SaslMessagePB::supported_features_size() const {
  return supported_features_.size();
}
inline void SaslMessagePB::clear_supported_features() {
  supported_features_.Clear();
}
inline ::base::rpc::RpcFeatureFlag SaslMessagePB::supported_features(int index) const {
  // @@protoc_insertion_point(field_get:base.rpc.SaslMessagePB.supported_features)
  return static_cast< ::base::rpc::RpcFeatureFlag >(supported_features_.Get(index));
}
inline void SaslMessagePB::set_supported_features(int index, ::base::rpc::RpcFeatureFlag value) {
  assert(::base::rpc::RpcFeatureFlag_IsValid(value));
  supported_features_.Set(index, value);
  // @@protoc_insertion_point(field_set:base.rpc.SaslMessagePB.supported_features)
}
inline void SaslMessagePB::add_supported_features(::base::rpc::RpcFeatureFlag value) {
  assert(::base::rpc::RpcFeatureFlag_IsValid(value));
  supported_features_.Add(value);
  // @@protoc_insertion_point(field_add:base.rpc.SaslMessagePB.supported_features)
}
inline const ::google::protobuf::RepeatedField<int>&
SaslMessagePB::supported_features() const {
  // @@protoc_insertion_point(field_list:base.rpc.SaslMessagePB.supported_features)
  return supported_features_;
}
inline ::google::protobuf::RepeatedField<int>*
SaslMessagePB::mutable_supported_features() {
  // @@protoc_insertion_point(field_mutable_list:base.rpc.SaslMessagePB.supported_features)
  return &supported_features_;
}

// required .base.rpc.SaslMessagePB.SaslState state = 2;
inline bool SaslMessagePB::has_state() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SaslMessagePB::set_has_state() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SaslMessagePB::clear_has_state() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SaslMessagePB::clear_state() {
  state_ = 999;
  clear_has_state();
}
inline ::base::rpc::SaslMessagePB_SaslState SaslMessagePB::state() const {
  // @@protoc_insertion_point(field_get:base.rpc.SaslMessagePB.state)
  return static_cast< ::base::rpc::SaslMessagePB_SaslState >(state_);
}
inline void SaslMessagePB::set_state(::base::rpc::SaslMessagePB_SaslState value) {
  assert(::base::rpc::SaslMessagePB_SaslState_IsValid(value));
  set_has_state();
  state_ = value;
  // @@protoc_insertion_point(field_set:base.rpc.SaslMessagePB.state)
}

// optional bytes token = 3;
inline bool SaslMessagePB::has_token() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void SaslMessagePB::set_has_token() {
  _has_bits_[0] |= 0x00000004u;
}
inline void SaslMessagePB::clear_has_token() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void SaslMessagePB::clear_token() {
  if (token_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    token_->clear();
  }
  clear_has_token();
}
inline const ::std::string& SaslMessagePB::token() const {
  // @@protoc_insertion_point(field_get:base.rpc.SaslMessagePB.token)
  return *token_;
}
inline void SaslMessagePB::set_token(const ::std::string& value) {
  set_has_token();
  if (token_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    token_ = new ::std::string;
  }
  token_->assign(value);
  // @@protoc_insertion_point(field_set:base.rpc.SaslMessagePB.token)
}
inline void SaslMessagePB::set_token(const char* value) {
  set_has_token();
  if (token_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    token_ = new ::std::string;
  }
  token_->assign(value);
  // @@protoc_insertion_point(field_set_char:base.rpc.SaslMessagePB.token)
}
inline void SaslMessagePB::set_token(const void* value, size_t size) {
  set_has_token();
  if (token_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    token_ = new ::std::string;
  }
  token_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:base.rpc.SaslMessagePB.token)
}
inline ::std::string* SaslMessagePB::mutable_token() {
  set_has_token();
  if (token_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    token_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:base.rpc.SaslMessagePB.token)
  return token_;
}
inline ::std::string* SaslMessagePB::release_token() {
  clear_has_token();
  if (token_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = token_;
    token_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void SaslMessagePB::set_allocated_token(::std::string* token) {
  if (token_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete token_;
  }
  if (token) {
    set_has_token();
    token_ = token;
  } else {
    clear_has_token();
    token_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:base.rpc.SaslMessagePB.token)
}

// repeated .base.rpc.SaslMessagePB.SaslAuth auths = 4;
inline int SaslMessagePB::auths_size() const {
  return auths_.size();
}
inline void SaslMessagePB::clear_auths() {
  auths_.Clear();
}
inline const ::base::rpc::SaslMessagePB_SaslAuth& SaslMessagePB::auths(int index) const {
  // @@protoc_insertion_point(field_get:base.rpc.SaslMessagePB.auths)
  return auths_.Get(index);
}
inline ::base::rpc::SaslMessagePB_SaslAuth* SaslMessagePB::mutable_auths(int index) {
  // @@protoc_insertion_point(field_mutable:base.rpc.SaslMessagePB.auths)
  return auths_.Mutable(index);
}
inline ::base::rpc::SaslMessagePB_SaslAuth* SaslMessagePB::add_auths() {
  // @@protoc_insertion_point(field_add:base.rpc.SaslMessagePB.auths)
  return auths_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::base::rpc::SaslMessagePB_SaslAuth >&
SaslMessagePB::auths() const {
  // @@protoc_insertion_point(field_list:base.rpc.SaslMessagePB.auths)
  return auths_;
}
inline ::google::protobuf::RepeatedPtrField< ::base::rpc::SaslMessagePB_SaslAuth >*
SaslMessagePB::mutable_auths() {
  // @@protoc_insertion_point(field_mutable_list:base.rpc.SaslMessagePB.auths)
  return &auths_;
}

// -------------------------------------------------------------------

// RemoteMethodPB

// required string service_name = 1;
inline bool RemoteMethodPB::has_service_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RemoteMethodPB::set_has_service_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RemoteMethodPB::clear_has_service_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RemoteMethodPB::clear_service_name() {
  if (service_name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    service_name_->clear();
  }
  clear_has_service_name();
}
inline const ::std::string& RemoteMethodPB::service_name() const {
  // @@protoc_insertion_point(field_get:base.rpc.RemoteMethodPB.service_name)
  return *service_name_;
}
inline void RemoteMethodPB::set_service_name(const ::std::string& value) {
  set_has_service_name();
  if (service_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    service_name_ = new ::std::string;
  }
  service_name_->assign(value);
  // @@protoc_insertion_point(field_set:base.rpc.RemoteMethodPB.service_name)
}
inline void RemoteMethodPB::set_service_name(const char* value) {
  set_has_service_name();
  if (service_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    service_name_ = new ::std::string;
  }
  service_name_->assign(value);
  // @@protoc_insertion_point(field_set_char:base.rpc.RemoteMethodPB.service_name)
}
inline void RemoteMethodPB::set_service_name(const char* value, size_t size) {
  set_has_service_name();
  if (service_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    service_name_ = new ::std::string;
  }
  service_name_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:base.rpc.RemoteMethodPB.service_name)
}
inline ::std::string* RemoteMethodPB::mutable_service_name() {
  set_has_service_name();
  if (service_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    service_name_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:base.rpc.RemoteMethodPB.service_name)
  return service_name_;
}
inline ::std::string* RemoteMethodPB::release_service_name() {
  clear_has_service_name();
  if (service_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = service_name_;
    service_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void RemoteMethodPB::set_allocated_service_name(::std::string* service_name) {
  if (service_name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete service_name_;
  }
  if (service_name) {
    set_has_service_name();
    service_name_ = service_name;
  } else {
    clear_has_service_name();
    service_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:base.rpc.RemoteMethodPB.service_name)
}

// required string method_name = 2;
inline bool RemoteMethodPB::has_method_name() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RemoteMethodPB::set_has_method_name() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RemoteMethodPB::clear_has_method_name() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RemoteMethodPB::clear_method_name() {
  if (method_name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    method_name_->clear();
  }
  clear_has_method_name();
}
inline const ::std::string& RemoteMethodPB::method_name() const {
  // @@protoc_insertion_point(field_get:base.rpc.RemoteMethodPB.method_name)
  return *method_name_;
}
inline void RemoteMethodPB::set_method_name(const ::std::string& value) {
  set_has_method_name();
  if (method_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    method_name_ = new ::std::string;
  }
  method_name_->assign(value);
  // @@protoc_insertion_point(field_set:base.rpc.RemoteMethodPB.method_name)
}
inline void RemoteMethodPB::set_method_name(const char* value) {
  set_has_method_name();
  if (method_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    method_name_ = new ::std::string;
  }
  method_name_->assign(value);
  // @@protoc_insertion_point(field_set_char:base.rpc.RemoteMethodPB.method_name)
}
inline void RemoteMethodPB::set_method_name(const char* value, size_t size) {
  set_has_method_name();
  if (method_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    method_name_ = new ::std::string;
  }
  method_name_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:base.rpc.RemoteMethodPB.method_name)
}
inline ::std::string* RemoteMethodPB::mutable_method_name() {
  set_has_method_name();
  if (method_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    method_name_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:base.rpc.RemoteMethodPB.method_name)
  return method_name_;
}
inline ::std::string* RemoteMethodPB::release_method_name() {
  clear_has_method_name();
  if (method_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = method_name_;
    method_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void RemoteMethodPB::set_allocated_method_name(::std::string* method_name) {
  if (method_name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete method_name_;
  }
  if (method_name) {
    set_has_method_name();
    method_name_ = method_name;
  } else {
    clear_has_method_name();
    method_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:base.rpc.RemoteMethodPB.method_name)
}

// -------------------------------------------------------------------

// RequestIdPB

// required string client_id = 1;
inline bool RequestIdPB::has_client_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RequestIdPB::set_has_client_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RequestIdPB::clear_has_client_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RequestIdPB::clear_client_id() {
  if (client_id_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    client_id_->clear();
  }
  clear_has_client_id();
}
inline const ::std::string& RequestIdPB::client_id() const {
  // @@protoc_insertion_point(field_get:base.rpc.RequestIdPB.client_id)
  return *client_id_;
}
inline void RequestIdPB::set_client_id(const ::std::string& value) {
  set_has_client_id();
  if (client_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    client_id_ = new ::std::string;
  }
  client_id_->assign(value);
  // @@protoc_insertion_point(field_set:base.rpc.RequestIdPB.client_id)
}
inline void RequestIdPB::set_client_id(const char* value) {
  set_has_client_id();
  if (client_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    client_id_ = new ::std::string;
  }
  client_id_->assign(value);
  // @@protoc_insertion_point(field_set_char:base.rpc.RequestIdPB.client_id)
}
inline void RequestIdPB::set_client_id(const char* value, size_t size) {
  set_has_client_id();
  if (client_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    client_id_ = new ::std::string;
  }
  client_id_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:base.rpc.RequestIdPB.client_id)
}
inline ::std::string* RequestIdPB::mutable_client_id() {
  set_has_client_id();
  if (client_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    client_id_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:base.rpc.RequestIdPB.client_id)
  return client_id_;
}
inline ::std::string* RequestIdPB::release_client_id() {
  clear_has_client_id();
  if (client_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = client_id_;
    client_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void RequestIdPB::set_allocated_client_id(::std::string* client_id) {
  if (client_id_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete client_id_;
  }
  if (client_id) {
    set_has_client_id();
    client_id_ = client_id;
  } else {
    clear_has_client_id();
    client_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:base.rpc.RequestIdPB.client_id)
}

// required int64 seq_no = 2;
inline bool RequestIdPB::has_seq_no() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RequestIdPB::set_has_seq_no() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RequestIdPB::clear_has_seq_no() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RequestIdPB::clear_seq_no() {
  seq_no_ = GOOGLE_LONGLONG(0);
  clear_has_seq_no();
}
inline ::google::protobuf::int64 RequestIdPB::seq_no() const {
  // @@protoc_insertion_point(field_get:base.rpc.RequestIdPB.seq_no)
  return seq_no_;
}
inline void RequestIdPB::set_seq_no(::google::protobuf::int64 value) {
  set_has_seq_no();
  seq_no_ = value;
  // @@protoc_insertion_point(field_set:base.rpc.RequestIdPB.seq_no)
}

// required int64 first_incomplete_seq_no = 3;
inline bool RequestIdPB::has_first_incomplete_seq_no() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void RequestIdPB::set_has_first_incomplete_seq_no() {
  _has_bits_[0] |= 0x00000004u;
}
inline void RequestIdPB::clear_has_first_incomplete_seq_no() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void RequestIdPB::clear_first_incomplete_seq_no() {
  first_incomplete_seq_no_ = GOOGLE_LONGLONG(0);
  clear_has_first_incomplete_seq_no();
}
inline ::google::protobuf::int64 RequestIdPB::first_incomplete_seq_no() const {
  // @@protoc_insertion_point(field_get:base.rpc.RequestIdPB.first_incomplete_seq_no)
  return first_incomplete_seq_no_;
}
inline void RequestIdPB::set_first_incomplete_seq_no(::google::protobuf::int64 value) {
  set_has_first_incomplete_seq_no();
  first_incomplete_seq_no_ = value;
  // @@protoc_insertion_point(field_set:base.rpc.RequestIdPB.first_incomplete_seq_no)
}

// required int64 attempt_no = 4;
inline bool RequestIdPB::has_attempt_no() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void RequestIdPB::set_has_attempt_no() {
  _has_bits_[0] |= 0x00000008u;
}
inline void RequestIdPB::clear_has_attempt_no() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void RequestIdPB::clear_attempt_no() {
  attempt_no_ = GOOGLE_LONGLONG(0);
  clear_has_attempt_no();
}
inline ::google::protobuf::int64 RequestIdPB::attempt_no() const {
  // @@protoc_insertion_point(field_get:base.rpc.RequestIdPB.attempt_no)
  return attempt_no_;
}
inline void RequestIdPB::set_attempt_no(::google::protobuf::int64 value) {
  set_has_attempt_no();
  attempt_no_ = value;
  // @@protoc_insertion_point(field_set:base.rpc.RequestIdPB.attempt_no)
}

// -------------------------------------------------------------------

// RequestHeader

// required int32 call_id = 3;
inline bool RequestHeader::has_call_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RequestHeader::set_has_call_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RequestHeader::clear_has_call_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RequestHeader::clear_call_id() {
  call_id_ = 0;
  clear_has_call_id();
}
inline ::google::protobuf::int32 RequestHeader::call_id() const {
  // @@protoc_insertion_point(field_get:base.rpc.RequestHeader.call_id)
  return call_id_;
}
inline void RequestHeader::set_call_id(::google::protobuf::int32 value) {
  set_has_call_id();
  call_id_ = value;
  // @@protoc_insertion_point(field_set:base.rpc.RequestHeader.call_id)
}

// optional .base.rpc.RemoteMethodPB remote_method = 6;
inline bool RequestHeader::has_remote_method() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RequestHeader::set_has_remote_method() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RequestHeader::clear_has_remote_method() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RequestHeader::clear_remote_method() {
  if (remote_method_ != NULL) remote_method_->::base::rpc::RemoteMethodPB::Clear();
  clear_has_remote_method();
}
inline const ::base::rpc::RemoteMethodPB& RequestHeader::remote_method() const {
  // @@protoc_insertion_point(field_get:base.rpc.RequestHeader.remote_method)
  return remote_method_ != NULL ? *remote_method_ : *default_instance_->remote_method_;
}
inline ::base::rpc::RemoteMethodPB* RequestHeader::mutable_remote_method() {
  set_has_remote_method();
  if (remote_method_ == NULL) remote_method_ = new ::base::rpc::RemoteMethodPB;
  // @@protoc_insertion_point(field_mutable:base.rpc.RequestHeader.remote_method)
  return remote_method_;
}
inline ::base::rpc::RemoteMethodPB* RequestHeader::release_remote_method() {
  clear_has_remote_method();
  ::base::rpc::RemoteMethodPB* temp = remote_method_;
  remote_method_ = NULL;
  return temp;
}
inline void RequestHeader::set_allocated_remote_method(::base::rpc::RemoteMethodPB* remote_method) {
  delete remote_method_;
  remote_method_ = remote_method;
  if (remote_method) {
    set_has_remote_method();
  } else {
    clear_has_remote_method();
  }
  // @@protoc_insertion_point(field_set_allocated:base.rpc.RequestHeader.remote_method)
}

// optional uint32 timeout_millis = 10;
inline bool RequestHeader::has_timeout_millis() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void RequestHeader::set_has_timeout_millis() {
  _has_bits_[0] |= 0x00000004u;
}
inline void RequestHeader::clear_has_timeout_millis() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void RequestHeader::clear_timeout_millis() {
  timeout_millis_ = 0u;
  clear_has_timeout_millis();
}
inline ::google::protobuf::uint32 RequestHeader::timeout_millis() const {
  // @@protoc_insertion_point(field_get:base.rpc.RequestHeader.timeout_millis)
  return timeout_millis_;
}
inline void RequestHeader::set_timeout_millis(::google::protobuf::uint32 value) {
  set_has_timeout_millis();
  timeout_millis_ = value;
  // @@protoc_insertion_point(field_set:base.rpc.RequestHeader.timeout_millis)
}

// repeated uint32 required_feature_flags = 11;
inline int RequestHeader::required_feature_flags_size() const {
  return required_feature_flags_.size();
}
inline void RequestHeader::clear_required_feature_flags() {
  required_feature_flags_.Clear();
}
inline ::google::protobuf::uint32 RequestHeader::required_feature_flags(int index) const {
  // @@protoc_insertion_point(field_get:base.rpc.RequestHeader.required_feature_flags)
  return required_feature_flags_.Get(index);
}
inline void RequestHeader::set_required_feature_flags(int index, ::google::protobuf::uint32 value) {
  required_feature_flags_.Set(index, value);
  // @@protoc_insertion_point(field_set:base.rpc.RequestHeader.required_feature_flags)
}
inline void RequestHeader::add_required_feature_flags(::google::protobuf::uint32 value) {
  required_feature_flags_.Add(value);
  // @@protoc_insertion_point(field_add:base.rpc.RequestHeader.required_feature_flags)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
RequestHeader::required_feature_flags() const {
  // @@protoc_insertion_point(field_list:base.rpc.RequestHeader.required_feature_flags)
  return required_feature_flags_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
RequestHeader::mutable_required_feature_flags() {
  // @@protoc_insertion_point(field_mutable_list:base.rpc.RequestHeader.required_feature_flags)
  return &required_feature_flags_;
}

// optional .base.rpc.RequestIdPB request_id = 15;
inline bool RequestHeader::has_request_id() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void RequestHeader::set_has_request_id() {
  _has_bits_[0] |= 0x00000010u;
}
inline void RequestHeader::clear_has_request_id() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void RequestHeader::clear_request_id() {
  if (request_id_ != NULL) request_id_->::base::rpc::RequestIdPB::Clear();
  clear_has_request_id();
}
inline const ::base::rpc::RequestIdPB& RequestHeader::request_id() const {
  // @@protoc_insertion_point(field_get:base.rpc.RequestHeader.request_id)
  return request_id_ != NULL ? *request_id_ : *default_instance_->request_id_;
}
inline ::base::rpc::RequestIdPB* RequestHeader::mutable_request_id() {
  set_has_request_id();
  if (request_id_ == NULL) request_id_ = new ::base::rpc::RequestIdPB;
  // @@protoc_insertion_point(field_mutable:base.rpc.RequestHeader.request_id)
  return request_id_;
}
inline ::base::rpc::RequestIdPB* RequestHeader::release_request_id() {
  clear_has_request_id();
  ::base::rpc::RequestIdPB* temp = request_id_;
  request_id_ = NULL;
  return temp;
}
inline void RequestHeader::set_allocated_request_id(::base::rpc::RequestIdPB* request_id) {
  delete request_id_;
  request_id_ = request_id;
  if (request_id) {
    set_has_request_id();
  } else {
    clear_has_request_id();
  }
  // @@protoc_insertion_point(field_set_allocated:base.rpc.RequestHeader.request_id)
}

// -------------------------------------------------------------------

// ResponseHeader

// required int32 call_id = 1;
inline bool ResponseHeader::has_call_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ResponseHeader::set_has_call_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ResponseHeader::clear_has_call_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ResponseHeader::clear_call_id() {
  call_id_ = 0;
  clear_has_call_id();
}
inline ::google::protobuf::int32 ResponseHeader::call_id() const {
  // @@protoc_insertion_point(field_get:base.rpc.ResponseHeader.call_id)
  return call_id_;
}
inline void ResponseHeader::set_call_id(::google::protobuf::int32 value) {
  set_has_call_id();
  call_id_ = value;
  // @@protoc_insertion_point(field_set:base.rpc.ResponseHeader.call_id)
}

// optional bool is_error = 2 [default = false];
inline bool ResponseHeader::has_is_error() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ResponseHeader::set_has_is_error() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ResponseHeader::clear_has_is_error() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ResponseHeader::clear_is_error() {
  is_error_ = false;
  clear_has_is_error();
}
inline bool ResponseHeader::is_error() const {
  // @@protoc_insertion_point(field_get:base.rpc.ResponseHeader.is_error)
  return is_error_;
}
inline void ResponseHeader::set_is_error(bool value) {
  set_has_is_error();
  is_error_ = value;
  // @@protoc_insertion_point(field_set:base.rpc.ResponseHeader.is_error)
}

// repeated uint32 sidecar_offsets = 3;
inline int ResponseHeader::sidecar_offsets_size() const {
  return sidecar_offsets_.size();
}
inline void ResponseHeader::clear_sidecar_offsets() {
  sidecar_offsets_.Clear();
}
inline ::google::protobuf::uint32 ResponseHeader::sidecar_offsets(int index) const {
  // @@protoc_insertion_point(field_get:base.rpc.ResponseHeader.sidecar_offsets)
  return sidecar_offsets_.Get(index);
}
inline void ResponseHeader::set_sidecar_offsets(int index, ::google::protobuf::uint32 value) {
  sidecar_offsets_.Set(index, value);
  // @@protoc_insertion_point(field_set:base.rpc.ResponseHeader.sidecar_offsets)
}
inline void ResponseHeader::add_sidecar_offsets(::google::protobuf::uint32 value) {
  sidecar_offsets_.Add(value);
  // @@protoc_insertion_point(field_add:base.rpc.ResponseHeader.sidecar_offsets)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
ResponseHeader::sidecar_offsets() const {
  // @@protoc_insertion_point(field_list:base.rpc.ResponseHeader.sidecar_offsets)
  return sidecar_offsets_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
ResponseHeader::mutable_sidecar_offsets() {
  // @@protoc_insertion_point(field_mutable_list:base.rpc.ResponseHeader.sidecar_offsets)
  return &sidecar_offsets_;
}

// -------------------------------------------------------------------

// ErrorStatusPB

// required string message = 1;
inline bool ErrorStatusPB::has_message() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ErrorStatusPB::set_has_message() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ErrorStatusPB::clear_has_message() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ErrorStatusPB::clear_message() {
  if (message_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    message_->clear();
  }
  clear_has_message();
}
inline const ::std::string& ErrorStatusPB::message() const {
  // @@protoc_insertion_point(field_get:base.rpc.ErrorStatusPB.message)
  return *message_;
}
inline void ErrorStatusPB::set_message(const ::std::string& value) {
  set_has_message();
  if (message_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    message_ = new ::std::string;
  }
  message_->assign(value);
  // @@protoc_insertion_point(field_set:base.rpc.ErrorStatusPB.message)
}
inline void ErrorStatusPB::set_message(const char* value) {
  set_has_message();
  if (message_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    message_ = new ::std::string;
  }
  message_->assign(value);
  // @@protoc_insertion_point(field_set_char:base.rpc.ErrorStatusPB.message)
}
inline void ErrorStatusPB::set_message(const char* value, size_t size) {
  set_has_message();
  if (message_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    message_ = new ::std::string;
  }
  message_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:base.rpc.ErrorStatusPB.message)
}
inline ::std::string* ErrorStatusPB::mutable_message() {
  set_has_message();
  if (message_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    message_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:base.rpc.ErrorStatusPB.message)
  return message_;
}
inline ::std::string* ErrorStatusPB::release_message() {
  clear_has_message();
  if (message_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = message_;
    message_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void ErrorStatusPB::set_allocated_message(::std::string* message) {
  if (message_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete message_;
  }
  if (message) {
    set_has_message();
    message_ = message;
  } else {
    clear_has_message();
    message_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:base.rpc.ErrorStatusPB.message)
}

// optional .base.rpc.ErrorStatusPB.RpcErrorCodePB code = 2;
inline bool ErrorStatusPB::has_code() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ErrorStatusPB::set_has_code() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ErrorStatusPB::clear_has_code() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ErrorStatusPB::clear_code() {
  code_ = 10;
  clear_has_code();
}
inline ::base::rpc::ErrorStatusPB_RpcErrorCodePB ErrorStatusPB::code() const {
  // @@protoc_insertion_point(field_get:base.rpc.ErrorStatusPB.code)
  return static_cast< ::base::rpc::ErrorStatusPB_RpcErrorCodePB >(code_);
}
inline void ErrorStatusPB::set_code(::base::rpc::ErrorStatusPB_RpcErrorCodePB value) {
  assert(::base::rpc::ErrorStatusPB_RpcErrorCodePB_IsValid(value));
  set_has_code();
  code_ = value;
  // @@protoc_insertion_point(field_set:base.rpc.ErrorStatusPB.code)
}

// repeated uint32 unsupported_feature_flags = 3;
inline int ErrorStatusPB::unsupported_feature_flags_size() const {
  return unsupported_feature_flags_.size();
}
inline void ErrorStatusPB::clear_unsupported_feature_flags() {
  unsupported_feature_flags_.Clear();
}
inline ::google::protobuf::uint32 ErrorStatusPB::unsupported_feature_flags(int index) const {
  // @@protoc_insertion_point(field_get:base.rpc.ErrorStatusPB.unsupported_feature_flags)
  return unsupported_feature_flags_.Get(index);
}
inline void ErrorStatusPB::set_unsupported_feature_flags(int index, ::google::protobuf::uint32 value) {
  unsupported_feature_flags_.Set(index, value);
  // @@protoc_insertion_point(field_set:base.rpc.ErrorStatusPB.unsupported_feature_flags)
}
inline void ErrorStatusPB::add_unsupported_feature_flags(::google::protobuf::uint32 value) {
  unsupported_feature_flags_.Add(value);
  // @@protoc_insertion_point(field_add:base.rpc.ErrorStatusPB.unsupported_feature_flags)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
ErrorStatusPB::unsupported_feature_flags() const {
  // @@protoc_insertion_point(field_list:base.rpc.ErrorStatusPB.unsupported_feature_flags)
  return unsupported_feature_flags_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
ErrorStatusPB::mutable_unsupported_feature_flags() {
  // @@protoc_insertion_point(field_mutable_list:base.rpc.ErrorStatusPB.unsupported_feature_flags)
  return &unsupported_feature_flags_;
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace rpc
}  // namespace base

#ifndef SWIG
namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::base::rpc::SaslMessagePB_SaslState> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::base::rpc::SaslMessagePB_SaslState>() {
  return ::base::rpc::SaslMessagePB_SaslState_descriptor();
}
template <> struct is_proto_enum< ::base::rpc::ErrorStatusPB_RpcErrorCodePB> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::base::rpc::ErrorStatusPB_RpcErrorCodePB>() {
  return ::base::rpc::ErrorStatusPB_RpcErrorCodePB_descriptor();
}
template <> struct is_proto_enum< ::base::rpc::RpcFeatureFlag> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::base::rpc::RpcFeatureFlag>() {
  return ::base::rpc::RpcFeatureFlag_descriptor();
}

}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_base_2frpc_2frpc_5fheader_2eproto__INCLUDED
